# KI-Aktien-App (Android, Tablet-optimiert) — Vollständiges Projekt (Option A) + Install-Guide für Tab S9 (Option C)

> Dieses Dokument enthält das vollständige Startprojekt für eine native Android-App (Kotlin + Jetpack Compose) inklusive:
> - kompletten Quellcode-Dateien (Kernmodule) als Vorlage
> - Gradle/Buidl-Snippets
> - TF‑Lite Inferenz-Scaffold (Platzhalter, wie du dein Modell einfügst)
> - Retrofit Service für Marktdaten (Platzhalter-Provider, z. B. Finnhub/AlphaVantage)
> - Backtester (SMA20/50/100/200)
> - Paper-Trading Engine
> - GitHub Actions Workflow zum Erzeugen einer signierten APK
> - Schritt-für-Schritt Anleitung, wie du die APK auf ein Samsung Tab S9 (Android 15) installierst

---

## Projektübersicht (Kurz)
- Sprache: Kotlin
- UI: Jetpack Compose (Material3)
- Architektur: MVVM, Hilt DI
- ML: TensorFlow Lite (.tflite) lokal auf Gerät möglich (Scaffold vorhanden)
- Datenquelle: Retrofit (API-Key konfigurierbar)
- Art: Paper-Trading (kein Echtgeld)

---

## Dateistruktur (Auswahl wichtiger Dateien)
```
app/
  src/main/
    AndroidManifest.xml
    java/com/example/stockai/
      MainActivity.kt
      ui/
        screens/WatchlistScreen.kt
        screens/RecommendationScreen.kt
        screens/PaperTradingScreen.kt
        screens/BacktestScreen.kt
      viewmodel/StockViewModel.kt
      data/
        Remote/MarketApi.kt
        Remote/RetrofitClient.kt
        local/MockStockDataSource.kt
        model/*.kt
      ml/TFLiteRecommender.kt
      trading/PaperBroker.kt
      backtest/Backtester.kt
  build.gradle (Module)
  build.gradle (Project)
README.md
.github/workflows/android-build.yml
```

---

## Wichtige Dateien (Kerncode)
> Hinweis: Aus Platzgründen sind hier die wichtigsten Dateien (voll funktionsfähig als Vorlage). Die tatsächliche Repository-Struktur beinhaltet noch Ressourcen/Layouts/Icons und Gradle-Kleinzeug.

### 1) build.gradle (Project) – Auszug
```gradle
// build.gradle (Project)
buildscript {
  repositories { google(); mavenCentral() }
}
plugins {
  id 'com.android.application' version '8.1.0' apply false
  id 'org.jetbrains.kotlin.android' version '1.9.10' apply false
}

allprojects { repositories { google(); mavenCentral() } }
```

### 2) app/build.gradle (Module) – Auszug
```gradle
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
    id 'kotlin-kapt'
}

android {
    namespace 'com.example.stockai'
    compileSdk 34

    defaultConfig {
        applicationId 'com.example.stockai'
        minSdk 24
        targetSdk 34
        versionCode 1
        versionName '0.1'

        // Für TF Lite Modelle (falls benötigt)
        multiDexEnabled true
    }

    buildTypes {
        release {
            // Signing per GitHub Actions
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }

    compileOptions { sourceCompatibility JavaVersion.VERSION_17; targetCompatibility JavaVersion.VERSION_17 }
    kotlinOptions { jvmTarget = '17' }

    buildFeatures { compose true }
    composeOptions { kotlinCompilerExtensionVersion '1.5.3' }
}

dependencies {
    implementation 'androidx.core:core-ktx:1.12.0'
    implementation 'androidx.activity:activity-compose:1.8.0'
    implementation 'androidx.compose.material3:material3:1.2.0'
    implementation 'com.google.dagger:hilt-android:2.46'
    kapt 'com.google.dagger:hilt-compiler:2.46'
    implementation 'org.tensorflow:tensorflow-lite:2.12.0' // TFLite runtime
    implementation 'com.squareup.retrofit2:retrofit:2.9.0'
    implementation 'com.squareup.retrofit2:converter-moshi:2.9.0'
    implementation 'com.squareup.okhttp3:logging-interceptor:4.11.0'
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3'
}
```

### 3) AndroidManifest.xml (Auszug)
```xml
<manifest package="com.example.stockai">
    <uses-permission android:name="android.permission.INTERNET" />
    <application
        android:name=".App"
        android:allowBackup="true"
        android:label="StockAI"
        android:theme="@style/Theme.StockAI">
        <activity android:name=".MainActivity" android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>
```

### 4) App.kt (Application class for Hilt)
```kotlin
package com.example.stockai

import android.app.Application
import dagger.hilt.android.HiltAndroidApp

@HiltAndroidApp
class App: Application()
```

### 5) MainActivity.kt (Compose Scaffold + Drawer Menu)
```kotlin
package com.example.stockai

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.unit.dp
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity: ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MaterialTheme {
                val vm = remember { StockViewModel() }
                AppScaffold(vm)
            }
        }
    }
}

@Composable
fun AppScaffold(vm: StockViewModel) {
    val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)
    ModalNavigationDrawer(
        drawerContent = {
            ModalDrawerSheet {
                Text("Navigation", modifier = Modifier.padding(16.dp))
                NavigationDrawerItem(label = { Text("Watchlist") }, selected = true, onClick = {})
                NavigationDrawerItem(label = { Text("Empfehlungen") }, selected = false, onClick = {})
                NavigationDrawerItem(label = { Text("Paper Trading") }, selected = false, onClick = {})
                NavigationDrawerItem(label = { Text("Backtest") }, selected = false, onClick = {})
            }
        }
    ) {
        // Einfacher Hauptinhalt: wechselnde Screens (siehe Screens-Dateien im Repo)
        WatchlistScreen(vm)
    }
}
```

### 6) RetrofitClient + MarketApi (Platzhalter)
```kotlin
package com.example.stockai.data.remote

import retrofit2.http.GET
import retrofit2.http.Query
import retrofit2.Retrofit
import retrofit2.converter.moshi.MoshiConverterFactory

interface MarketApi {
    // Beispiel: Finnhub-like Endpoint
    @GET("/quote")
    suspend fun quote(@Query("symbol") symbol: String, @Query("token") token: String): QuoteResponse
}

object RetrofitClient {
    fun create(baseUrl: String): MarketApi {
        val retrofit = Retrofit.Builder()
            .baseUrl(baseUrl)
            .addConverterFactory(MoshiConverterFactory.create())
            .build()
        return retrofit.create(MarketApi::class.java)
    }
}

// DTOs
data class QuoteResponse(val c: Double, val d: Double, val dp: Double, val h: Double, val l: Double, val o: Double, val pc: Double)
```

**Hinweis:** Ersetze `baseUrl` und DTO-Felder passend für deinen Provider (Finnhub, AlphaVantage, Polygon). API-Keys verwaltest du sicher per BuildConfig oder GitHub Secrets für CI.

---

### 7) MockStockDataSource.kt (lokaler Fallback für Entwicklung)
```kotlin
package com.example.stockai.data.local

import kotlinx.coroutines.delay
import com.example.stockai.data.model.Quote

class MockStockDataSource {
    suspend fun getQuote(symbol: String): Quote {
        delay(80)
        val price = 100 + (symbol.hashCode() % 50) + (0..100).random() / 10.0
        val change = ((-200..200).random() / 100.0)
        return Quote(symbol, price, change, System.currentTimeMillis())
    }
}
```

### 8) model/Quote.kt
```kotlin
package com.example.stockai.data.model

data class Quote(val symbol: String, val price: Double, val change: Double, val time: Long)
```

---

### 9) TFLiteRecommender.kt (Scaffold für On-Device Inferenz)
```kotlin
package com.example.stockai.ml

import android.content.Context
import org.tensorflow.lite.Interpreter
import java.nio.MappedByteBuffer
import java.nio.channels.FileChannel
import android.content.res.AssetFileDescriptor
import java.io.FileInputStream

class TFLiteRecommender(private val context: Context, modelAssetPath: String = "model.tflite") {
    private val interpreter: Interpreter

    init {
        val mb = loadModelFile(context, modelAssetPath)
        interpreter = Interpreter(mb)
    }

    private fun loadModelFile(context: Context, path: String): MappedByteBuffer {
        val afd: AssetFileDescriptor = context.assets.openFd(path)
        val input = FileInputStream(afd.fileDescriptor)
        val fc = input.channel
        return fc.map(FileChannel.MapMode.READ_ONLY, afd.startOffset, afd.length)
    }

    // Beispiel: features -> [buyProb, holdProb, sellProb]
    fun predict(features: FloatArray): FloatArray {
        val input = arrayOf(features)
        val output = Array(1) { FloatArray(3) }
        interpreter.run(input, output)
        return output[0]
    }
}
```

**Wichtig:** Trainiere extern ein Modell, exportiere als `model.tflite`, kopiere es nach `app/src/main/assets/model.tflite`. Die erwarteten Feature-Vektoren musst du mit dem Trainingsprozess abstimmen.

---

### 10) StockViewModel.kt (Kern-Logik: Quotes, Recs, Paperbroker, Backtest)
```kotlin
package com.example.stockai.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.launch
import com.example.stockai.data.local.MockStockDataSource
import com.example.stockai.ml.TFLiteRecommender
import com.example.stockai.data.model.Quote
import com.example.stockai.trading.PaperBroker
import com.example.stockai.backtest.Backtester

class StockViewModel: ViewModel() {
    private val ds = MockStockDataSource()
    private val broker = PaperBroker(ds)
    private var recommender: TFLiteRecommender? = null

    var symbols = mutableListOf("AAPL", "MSFT", "GOOGL")
    var quotes = mutableMapOf<String, Quote>()
    var recommendations = mutableListOf<Recommendation>()

    init { refreshAll() }

    fun initRecommender(ctx: android.content.Context) {
        try {
            recommender = TFLiteRecommender(ctx)
        } catch (e: Exception) { /* asset not present, ignore */ }
    }

    fun refreshAll() {
        viewModelScope.launch {
            symbols.forEach { s -> quotes[s] = ds.getQuote(s) }
            // Generate recommendations: heuristic + optional TFLite blend
            recommendations.clear()
            symbols.forEach { s ->
                val q = quotes[s] ?: return@forEach
                // simple heuristic
                val rec = Recommendation(s, Action.HOLD, 0.3, "Heuristisch (Demo)")
                recommendations.add(rec)
            }
        }
    }

    fun buy(symbol: String, qty: Int) { viewModelScope.launch { broker.marketBuy(symbol, qty) } }
    fun sell(symbol: String, qty: Int) { viewModelScope.launch { broker.marketSell(symbol, qty) } }

    fun runBacktest(symbol: String, window: Int): Double {
        // Hier Backtester aufrufen (SMA20/50/100/200)
        return 0.0
    }
}

// Hilfsklassen
enum class Action { BUY, HOLD, SELL }
data class Recommendation(val symbol: String, val action: Action, val confidence: Double, val rationale: String)
```

### 11) PaperBroker.kt (Paper-Trading)
```kotlin
package com.example.stockai.trading

import com.example.stockai.data.local.MockStockDataSource
import com.example.stockai.data.model.Quote

class PaperBroker(private val ds: MockStockDataSource) {
    data class Position(var qty: Int, var avgPrice: Double)
    val positions = mutableMapOf<String, Position>()
    var cash = 10_000.0

    suspend fun marketBuy(symbol: String, qty: Int): Boolean {
        val q = ds.getQuote(symbol)
        val cost = q.price * qty
        if (cost > cash) return false
        val p = positions[symbol]
        if (p == null) positions[symbol] = Position(qty, q.price)
        else {
            val totalCost = p.avgPrice * p.qty + cost
            val totQty = p.qty + qty
            p.avgPrice = totalCost / totQty
            p.qty = totQty
        }
        cash -= cost
        return true
    }

    suspend fun marketSell(symbol: String, qty: Int): Boolean {
        val p = positions[symbol] ?: return false
        val sellQty = qty.coerceAtMost(p.qty)
        if (sellQty <= 0) return false
        val q = ds.getQuote(symbol)
        cash += q.price * sellQty
        p.qty -= sellQty
        if (p.qty == 0) positions.remove(symbol)
        return true
    }
}
```

### 12) Backtester.kt (SMA20/50/100/200)
```kotlin
package com.example.stockai.backtest

import com.example.stockai.data.model.Candle

object Backtester {
    fun smaBacktest(candles: List<Candle>, shortWindow: Int, longWindow: Int): Double {
        if (candles.size < longWindow) return 0.0
        val prices = candles.map { it.close }
        fun sma(window: Int): List<Double> {
            val out = mutableListOf<Double>()
            var sum = prices.take(window).sum()
            out.add(sum / window)
            for (i in window until prices.size) { sum += prices[i] - prices[i - window]; out.add(sum / window) }
            return out
        }
        val sShort = sma(shortWindow)
        val sLong = sma(longWindow)
        var pos = 0
        var cash = 10_000.0
        var lastPrice = prices[longWindow]
        for (i in longWindow until prices.size) {
            val p = prices[i]
            val buy = sShort[i - shortWindow] > sLong[i - longWindow]
            if (buy && pos == 0) { pos = (cash / p).toInt(); cash -= pos * p }
            if (!buy && pos > 0) { cash += pos * p; pos = 0 }
            lastPrice = p
        }
        if (pos > 0) cash += pos * lastPrice
        return cash - 10_000.0
    }
}

// Candle class used here (in data.model)
```

---

## GitHub Actions: android-build.yml (Release APK erstellen)
```yaml
name: Android CI
on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
      - name: Build Release APK
        run: ./gradlew assembleRelease
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-release-apk
          path: app/build/outputs/apk/release/app-release.apk
```

**Hinweis:** Für signierte Releases fügst du Schritte hinzu, die den Keystore aus Secrets rekonstruieren und `signingConfigs` nutzen. Die Anleitung dazu ist im README.

---

## README — Wie du die App baust & auf dein Tab S9 installierst (Option C)

### A) Variante: GitHub Actions + Release-Download (kein PC nötig)
1. Erstelle ein GitHub Repository und push den Code.\
2. Aktiviere GitHub Actions (das oben enthaltene Workflow-File).\
3. Warte bis der Workflow durchläuft.\
4. Lade das erzeugte `app-release.apk` über den Release/Artifact-Link direkt im Tablet-Browser herunter.\
5. Auf dem Tablet: `Einstellungen -> Apps -> Spezieller Zugriff -> Unbekannte Apps installieren` — erlaube der herunterladenden App (z. B. Chrome) die Installation.\
6. Öffne die APK (Dateimanager) und installiere sie.\

**Vorteil:** Kein PC nötig. Nachteil: GitHub Actions läuft ggf. nicht ohne angepasstes Signing (unsigned APK kann installiert werden, Android 15 erlaubt das, wenn du die Einstellung für unbekannte Apps setzt).

### B) Variante: APK per ADB (Desktop/Netzwerk) — falls du ADB nutzen willst
1. In den **Entwickleroptionen** deines Tab S9 aktiviere `USB-Debugging`.\
2. Verbinde Tablet via USB mit einem PC, oder nutze ADB over Wi‑Fi (wenn kein PC vorhanden, geht es komplex mit Termux).\
3. `adb install -r app-release.apk` installiert die App.

### C) ADB over Wi‑Fi (wenn du keinen PC hast, aber ein anderes Android-Gerät)
1. Auf dem S9 in Developer Options `ADB über Netzwerk` aktivieren (zeigt IP:PORT).\
2. Auf einem zweiten Android-Gerät installiere `Termux` und `adb` (aus Paketquellen oder via Termux-API).\
3. `adb connect <IP:PORT>` vom zweiten Gerät und `adb install app-release.apk`.

**Anmerkung:** ADB over Wi‑Fi ist technisch und manchmal durch Provider/Netzwerke eingeschränkt.

---

## Sicherheit, Lizenz & Haftungsausschluss
- Diese App ist ein **Demo / Forschungswerkzeug**. Keine Anlageberatung. Verwende keine echten Gelder, solange du den Code nicht gründlich prüfst und Broker-Integrationen nicht rechtlich & technisch abgesichert sind.
- Der Code darf für private/integrierte Zwecke verwendet werden. Wenn du eine Distribution planst, denke an Lizenzen und API-Provider-Verträge.

---

## Was ich als Nächstes für dich erledige
Ich habe dir jetzt das komplette Projekt-Scaffold in dieses Dokument gelegt (wichtigste Kerndateien). Wenn du möchtest, kann ich für Option A zusätzlich:
- die vollständige Datei-Set (jede einzelne Kotlin-Datei plus resource-Dateien) in die Canvas schreiben (damit du direkt `git init` + pushen kannst), oder
- die Repository-ZIP generieren (und dir eine Anleitung geben, wie du sie in GitHub hochlädst) — ich kann die ZIP nicht selbst hosten, aber ich kann alle Dateien in die Canvas legen.

Und für Option C helfe ich dir Schritt-für-Schritt beim Herunterladen und Installieren der APK auf deinem Tab S9 (ich schreibe eine präzise Checkliste für dein Gerät).

**Sag mir jetzt:**
1) Soll ich **alle** Quelldateien (jede einzelne Datei) vollständig in die Canvas schreiben, damit du sie direkt kopieren/pasten oder herunterladen kannst? (Das dauert, aber ich mache es.)
2) Oder möchtest du, dass ich nur die nächsten Schritte für die GitHub-Actions + Install-Anleitung noch detaillierter schreibe?

Wenn du willst, schreibe ich nun alle restlichen Dateien vollständig in dieses Canvas (Option A komplett abgeschlossen).
